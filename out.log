
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

* Project '~/Dropbox/skole_backup/postdoc/ghq-cpp' loaded. [renv 0.13.2]
> Rcpp::sourceCpp('ghq-cpp.cpp')

> set.seed(1)

> n <- 3

> Sigma <- as.matrix(drop(rWishart(1, 2 * n, diag(1/n, 
+     n))))

> mu <- rnorm(n)

> tval <- runif(n, -1)

> n_points <- 10

> ghq_dat <- fastGHQuad::gaussHermiteData(n_points)

> truth <- drop(exp(tval %*% mu + tval %*% Sigma %*% 
+     tval/2))

> do_comp <- function(target_size, n_rep = 1) mult_norm_moment(t = tval, 
+     mu = mu, Sigma = Sigma, weights = ghq_dat$w, nodes = ghq_dat$x, 
+     .... [TRUNCATED] 

> all.equal(do_comp(1), truth)
[1] "Mean relative difference: 1.075019e-07"

> all.equal(do_comp(n_points), truth)
[1] "Mean relative difference: 1.075019e-07"

> all.equal(do_comp(n_points^2), truth)
[1] "Mean relative difference: 1.075019e-07"

> bench::mark(GHQ1 = do_comp(target_size = n_points, 
+     n_rep = 1000), GHQ2 = do_comp(target_size = n_points^2, n_rep = 1000), 
+     GHQ2 = do_co .... [TRUNCATED] 
[38;5;246m# A tibble: 3 Ã— 13[39m
  expression     min  median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time
  [3m[38;5;246m<bch:expr>[39m[23m [3m[38;5;246m<bch:t>[39m[23m [3m[38;5;246m<bch:t>[39m[23m     [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<bch:byt>[39m[23m    [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<dbl>[39m[23m   [3m[38;5;246m<bch:tm>[39m[23m
[38;5;250m1[39m GHQ1        9.97ms 10.26ms      97.2        0B        0    49     0      504ms
[38;5;250m2[39m GHQ2        9.95ms 10.06ms      99.1        0B        0    50     0      504ms
[38;5;250m3[39m GHQ2        8.72ms  8.87ms     112.         0B        0    57     0      508ms
[38;5;246m# â€¦ with 4 more variables: result <list>, memory <list>, time <list>, gc <list>[39m

> set.seed(1)

> n_obs <- 3

> n <- 3

> Sigma <- as.matrix(drop(rWishart(1, 2 * n, diag(1/n, 
+     n))))

> eta <- matrix(runif(n_obs * n, -1), nrow = n)

> u <- drop(mvtnorm::rmvnorm(1, sigma = Sigma))

> lp <- eta + u

> p_hats <- rbind(1, exp(lp))/rep(1 + colSums(exp(lp)), 
+     each = n + 1)

> which_cat <- apply(p_hats, 2, function(x) sample.int(n + 
+     1, 1, prob = x))

> rm(u, lp, p_hats)

> brute_ests <- apply(mvtnorm::rmvnorm(1e+05, sigma = Sigma), 
+     1, function(u) {
+         exp_lp <- exp(eta + u)
+         denom <- 1 + colSums( .... [TRUNCATED] 

> se <- sd(brute_ests)/sqrt(length(brute_ests))

> brute_est <- mean(brute_ests)

> n_points <- 5

> ghq_dat <- fastGHQuad::gaussHermiteData(n_points)

> do_comp <- function(target_size, n_rep = 1, use_adaptive = FALSE) mixed_mult_logit_term(eta = eta, 
+     Sigma = Sigma, which_category = which_cat  .... [TRUNCATED] 

> se/abs(brute_est)
[1] 0.004845105

> all.equal(do_comp(n_points), brute_est)
[1] "Mean relative difference: 0.03573777"

> all.equal(do_comp(n_points^2), brute_est)
[1] "Mean relative difference: 0.03573777"

> all.equal(do_comp(n_points^3), brute_est)
[1] "Mean relative difference: 0.03573777"

> log_integrand <- function(x) {
+     x <- drop(crossprod(chol(Sigma), x))
+     exp_lp <- exp(eta + x)
+     denom <- 1 + colSums(exp_lp)
+     num  .... [TRUNCATED] 

> log_integrand_cpp <- function(ders) mixed_mult_logit_term_log_integrand(point = point, 
+     eta = eta, Sigma = Sigma, which_category = which_cat - .... [TRUNCATED] 

> point <- runif(n, -1)

> all.equal(log_integrand(point), log_integrand_cpp(0))
[1] TRUE

> f <- log_integrand_cpp(1)[1]

> g <- log_integrand_cpp(1)[-1]

> all.equal(log_integrand(point), f)
[1] TRUE

> all.equal(numDeriv::grad(log_integrand, point), g)
[1] TRUE

> all.equal(c(numDeriv::hessian(log_integrand, point)), 
+     log_integrand_cpp(2))
[1] TRUE

> se/abs(brute_est)
[1] 0.004845105

> all.equal(do_comp(n_points, use_adaptive = TRUE), 
+     brute_est)
[1] "Mean relative difference: 0.003522353"

> all.equal(do_comp(n_points^2, use_adaptive = TRUE), 
+     brute_est)
[1] "Mean relative difference: 0.003522353"

> all.equal(do_comp(n_points^3, use_adaptive = TRUE), 
+     brute_est)
[1] "Mean relative difference: 0.003522353"

> bench::mark(GHQ1 = do_comp(target_size = n_points, 
+     use_adaptive = FALSE, n_rep = 1000), GHQ2 = do_comp(target_size = n_points^2, 
+     use_a .... [TRUNCATED] 
[38;5;246m# A tibble: 6 Ã— 13[39m
  expression         min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc
  [3m[38;5;246m<bch:expr>[39m[23m    [3m[38;5;246m<bch:tm>[39m[23m [3m[38;5;246m<bch:tm>[39m[23m     [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<bch:byt>[39m[23m    [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<dbl>[39m[23m
[38;5;250m1[39m GHQ1            9.26ms   9.57ms     104.         0B        0    53     0
[38;5;250m2[39m GHQ2            9.21ms   9.29ms     106.         0B        0    54     0
[38;5;250m3[39m GHQ3             8.1ms   8.23ms     120.         0B        0    61     0
[38;5;250m4[39m GHQ1 adaptive  12.21ms  12.44ms      80.2        0B        0    41     0
[38;5;250m5[39m GHQ2 adaptive  12.33ms  12.42ms      80.5        0B        0    41     0
[38;5;250m6[39m GHQ3 adaptive   9.92ms  10.02ms      99.5        0B        0    50     0
[38;5;246m# â€¦ with 5 more variables: total_time <bch:tm>, result <list>, memory <list>,[39m
[38;5;246m#   time <list>, gc <list>[39m

> num_grad <- numDeriv::grad(function(par) {
+     e <- matrix(par[seq_along(eta)], nrow = NROW(eta))
+     S <- matrix(nrow = NROW(Sigma), ncol = NCO .... [TRUNCATED] 

> do_comp_grad <- function(target_size, n_rep = 1, use_adaptive = FALSE, 
+     use_comb = FALSE) {
+     res <- if (use_comb) 
+         mixed_mult_l .... [TRUNCATED] 

> grad_cpp <- do_comp_grad(n_points, use_adaptive = TRUE)

> all.equal(do_comp(n_points, use_adaptive = TRUE), 
+     grad_cpp[1])
[1] TRUE

> all.equal(num_grad, grad_cpp[-1])
[1] "Mean relative difference: 0.001030137"

> grad_cpp_comb <- do_comp_grad(n_points, use_adaptive = TRUE, 
+     use_comb = TRUE)

> all.equal(grad_cpp, grad_cpp_comb)
[1] TRUE

> bench::mark(`GHQ1 adaptive` = do_comp_grad(target_size = n_points, 
+     use_adaptive = TRUE, n_rep = 1000), `GHQ2 adaptive` = do_comp_grad(target_ .... [TRUNCATED] 
[38;5;246m# A tibble: 3 Ã— 13[39m
  expression                 min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc
  [3m[38;5;246m<bch:expr>[39m[23m             [3m[38;5;246m<bch:t>[39m[23m [3m[38;5;246m<bch:>[39m[23m     [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<bch:byt>[39m[23m    [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<dbl>[39m[23m
[38;5;250m1[39m GHQ1 adaptive           18.4ms 18.9ms      52.8    5.12KB        0    27     0
[38;5;250m2[39m GHQ2 adaptive           18.4ms 18.9ms      52.9      200B        0    27     0
[38;5;250m3[39m GHQ2 adaptive combined    21ms 21.4ms      46.4    5.19KB        0    24     0
[38;5;246m# â€¦ with 5 more variables: total_time <bch:tm>, result <list>, memory <list>,[39m
[38;5;246m#   time <list>, gc <list>[39m

> set.seed(1)

> n_obs <- 2

> n <- 3

> Sigma <- as.matrix(drop(rWishart(1, 2 * n, diag(1/n, 
+     n))))

> eta <- matrix(runif(n_obs * n, -1), nrow = n)

> z <- runif(n, -1)

> probit_eta <- runif(1, -1)

> u <- drop(mvtnorm::rmvnorm(1, sigma = Sigma))

> lp <- eta + u

> p_hats <- rbind(1, exp(lp))/rep(1 + colSums(exp(lp)), 
+     each = n + 1)

> which_cat <- apply(p_hats, 2, function(x) sample.int(n + 
+     1, 1, prob = x))

> sign_probit <- drop((pnorm(probit_eta + z %*% u) > 
+     runif(1)))

> if (!sign_probit) {
+     z <- -z
+     probit_eta <- -probit_eta
+ }

> rm(u, lp, p_hats, sign_probit)

> brute_ests <- apply(mvtnorm::rmvnorm(1e+05, sigma = Sigma), 
+     1, function(u) {
+         exp_lp <- exp(eta + u)
+         denom <- 1 + colSums( .... [TRUNCATED] 

> se <- sd(brute_ests)/sqrt(length(brute_ests))

> brute_est <- mean(brute_ests)

> n_points <- 5

> ghq_dat <- fastGHQuad::gaussHermiteData(n_points)

> do_comp <- function(target_size, n_rep = 1, use_adaptive = FALSE) mixed_mult_logit_n_probit(eta = eta, 
+     Sigma = Sigma, which_category = which_ .... [TRUNCATED] 

> se/abs(brute_est)
[1] 0.005465469

> all.equal(do_comp(n_points), brute_est)
[1] "Mean relative difference: 0.01448755"

> log_integrand <- function(x) {
+     x <- drop(crossprod(chol(Sigma), x))
+     drop(pnorm(probit_eta + z %*% x, log.p = TRUE))
+ }

> log_integrand_cpp <- function(ders) mixed_probit_log_integrand(point = point, 
+     probit_eta = probit_eta, Sigma = Sigma, z = z, ders = ders)

> point <- runif(n, -1)

> all.equal(log_integrand(point), log_integrand_cpp(0))
[1] TRUE

> f <- log_integrand_cpp(1)[1]

> g <- log_integrand_cpp(1)[-1]

> all.equal(log_integrand(point), f)
[1] TRUE

> all.equal(numDeriv::grad(log_integrand, point), g)
[1] TRUE

> all.equal(c(numDeriv::hessian(log_integrand, point)), 
+     log_integrand_cpp(2))
[1] TRUE

> se/abs(brute_est)
[1] 0.005465469

> all.equal(do_comp(n_points, use_adaptive = TRUE), 
+     brute_est)
[1] "Mean relative difference: 0.0006243278"

> num_grad <- numDeriv::grad(function(par) {
+     e <- matrix(par[seq_along(eta)], nrow = NROW(eta))
+     par <- par[-seq_along(eta)]
+     e_prob < .... [TRUNCATED] 

> do_comp_grad <- function(target_size, n_rep = 1, use_adaptive = FALSE) {
+     res <- mixed_mult_logit_n_probit_grad(eta = eta, Sigma = Sigma, 
+    .... [TRUNCATED] 

> est <- do_comp_grad(n_points, use_adaptive = TRUE)

> all.equal(brute_est, est[1])
[1] "Mean relative difference: 0.0006247178"

> all.equal(num_grad, est[-1])
[1] "Mean relative difference: 0.002090637"

> bench::mark(Func = do_comp(target_size = n_points^2, 
+     n_rep = 1000), `Func adaptive` = do_comp(target_size = n_points^2, 
+     n_rep = 1000,  .... [TRUNCATED] 
[38;5;246m# A tibble: 4 Ã— 13[39m
  expression         min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc
  [3m[38;5;246m<bch:expr>[39m[23m    [3m[38;5;246m<bch:tm>[39m[23m [3m[38;5;246m<bch:tm>[39m[23m     [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<bch:byt>[39m[23m    [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<dbl>[39m[23m
[38;5;250m1[39m Func            14.4ms   14.9ms      67.0        0B        0    34     0
[38;5;250m2[39m Func adaptive   16.9ms   17.1ms      58.3        0B        0    30     0
[38;5;250m3[39m Grad            22.3ms   22.4ms      44.4    5.38KB        0    23     0
[38;5;250m4[39m Grad adaptive   25.7ms   26.1ms      38.0      392B        0    20     0
[38;5;246m# â€¦ with 5 more variables: total_time <bch:tm>, result <list>, memory <list>,[39m
[38;5;246m#   time <list>, gc <list>[39m
> 
> 
