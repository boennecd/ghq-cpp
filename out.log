
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

* Project '~/Dropbox/skole_backup/postdoc/ghq-cpp' loaded. [renv 0.13.2]
> Rcpp::sourceCpp('ghq-cpp.cpp')

> set.seed(1)

> n <- 3

> Sigma <- as.matrix(drop(rWishart(1, 2 * n, diag(1/n, 
+     n))))

> mu <- rnorm(n)

> tval <- runif(n, -1)

> n_points <- 10

> ghq_dat <- fastGHQuad::gaussHermiteData(n_points)

> truth <- drop(exp(tval %*% mu + tval %*% Sigma %*% 
+     tval/2))

> do_comp <- function(target_size, n_rep = 1) mult_norm_moment(t = tval, 
+     mu = mu, Sigma = Sigma, weights = ghq_dat$w, nodes = ghq_dat$x, 
+     .... [TRUNCATED] 

> all.equal(do_comp(1), truth)
[1] "Mean relative difference: 1.075019e-07"

> all.equal(do_comp(n_points), truth)
[1] "Mean relative difference: 1.075019e-07"

> all.equal(do_comp(n_points^2), truth)
[1] "Mean relative difference: 1.075019e-07"

> bench::mark(GHQ1 = do_comp(target_size = n_points, 
+     n_rep = 1000), GHQ2 = do_comp(target_size = n_points^2, n_rep = 1000), 
+     GHQ2 = do_co .... [TRUNCATED] 
[38;5;246m# A tibble: 3 Ã— 13[39m
  expression     min  median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time
  [3m[38;5;246m<bch:expr>[39m[23m [3m[38;5;246m<bch:t>[39m[23m [3m[38;5;246m<bch:t>[39m[23m     [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<bch:byt>[39m[23m    [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<dbl>[39m[23m   [3m[38;5;246m<bch:tm>[39m[23m
[38;5;250m1[39m GHQ1        9.98ms 10.03ms      99.4        0B        0    50     0      503ms
[38;5;250m2[39m GHQ2        9.97ms 10.07ms      97.6        0B        0    49     0      502ms
[38;5;250m3[39m GHQ2        8.62ms  8.64ms     115.         0B        0    58     0      504ms
[38;5;246m# â€¦ with 4 more variables: result <list>, memory <list>, time <list>, gc <list>[39m

> set.seed(1)

> n_obs <- 3

> n <- 3

> Sigma <- as.matrix(drop(rWishart(1, 2 * n, diag(1/n, 
+     n))))

> eta <- matrix(runif(n_obs * n, -1), nrow = n)

> u <- drop(mvtnorm::rmvnorm(1, sigma = Sigma))

> lp <- eta + u

> p_hats <- rbind(1, exp(lp))/rep(1 + colSums(exp(lp)), 
+     each = n + 1)

> which_cat <- apply(p_hats, 2, function(x) sample.int(n + 
+     1, 1, prob = x))

> rm(u, lp, p_hats)

> brute_ests <- apply(mvtnorm::rmvnorm(1e+05, sigma = Sigma), 
+     1, function(u) {
+         exp_lp <- exp(eta + u)
+         denom <- 1 + colSums( .... [TRUNCATED] 

> se <- sd(brute_ests)/sqrt(length(brute_ests))

> brute_est <- mean(brute_ests)

> n_points <- 5

> ghq_dat <- fastGHQuad::gaussHermiteData(n_points)

> do_comp <- function(target_size, n_rep = 1, use_adaptive = FALSE) mixed_mult_logit_term(eta = eta, 
+     Sigma = Sigma, which_category = which_cat  .... [TRUNCATED] 

> se/abs(brute_est)
[1] 0.004845105

> all.equal(do_comp(n_points), brute_est)
[1] "Mean relative difference: 0.03573777"

> all.equal(do_comp(n_points^2), brute_est)
[1] "Mean relative difference: 0.03573777"

> all.equal(do_comp(n_points^3), brute_est)
[1] "Mean relative difference: 0.03573777"

> log_integrand <- function(x) {
+     x <- drop(crossprod(chol(Sigma), x))
+     exp_lp <- exp(eta + x)
+     denom <- 1 + colSums(exp_lp)
+     num  .... [TRUNCATED] 

> log_integrand_cpp <- function(ders) mixed_mult_logit_term_log_integrand(point = point, 
+     eta = eta, Sigma = Sigma, which_category = which_cat - .... [TRUNCATED] 

> point <- runif(n, -1)

> all.equal(log_integrand(point), log_integrand_cpp(0))
[1] TRUE

> f <- log_integrand_cpp(1)[1]

> g <- log_integrand_cpp(1)[-1]

> all.equal(log_integrand(point), f)
[1] TRUE

> all.equal(numDeriv::grad(log_integrand, point), g)
[1] TRUE

> all.equal(c(numDeriv::hessian(log_integrand, point)), 
+     log_integrand_cpp(2))
[1] TRUE

> se/abs(brute_est)
[1] 0.004845105

> all.equal(do_comp(n_points, use_adaptive = TRUE), 
+     brute_est)
[1] "Mean relative difference: 0.003522353"

> all.equal(do_comp(n_points^2, use_adaptive = TRUE), 
+     brute_est)
[1] "Mean relative difference: 0.003522353"

> all.equal(do_comp(n_points^3, use_adaptive = TRUE), 
+     brute_est)
[1] "Mean relative difference: 0.003522353"

> bench::mark(GHQ1 = do_comp(target_size = n_points, 
+     use_adaptive = FALSE, n_rep = 1000), GHQ2 = do_comp(target_size = n_points^2, 
+     use_a .... [TRUNCATED] 
[38;5;246m# A tibble: 6 Ã— 13[39m
  expression         min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc
  [3m[38;5;246m<bch:expr>[39m[23m    [3m[38;5;246m<bch:tm>[39m[23m [3m[38;5;246m<bch:tm>[39m[23m     [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<bch:byt>[39m[23m    [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<dbl>[39m[23m
[38;5;250m1[39m GHQ1            9.76ms     10ms      99.0        0B        0    50     0
[38;5;250m2[39m GHQ2            9.78ms    9.8ms     102.         0B        0    51     0
[38;5;250m3[39m GHQ3            8.77ms    8.8ms     113.         0B        0    57     0
[38;5;250m4[39m GHQ1 adaptive  12.81ms   12.9ms      77.7        0B        0    39     0
[38;5;250m5[39m GHQ2 adaptive  12.81ms   12.8ms      77.2        0B        0    39     0
[38;5;250m6[39m GHQ3 adaptive  10.25ms   10.5ms      95.6        0B        0    48     0
[38;5;246m# â€¦ with 5 more variables: total_time <bch:tm>, result <list>, memory <list>,[39m
[38;5;246m#   time <list>, gc <list>[39m

> num_grad <- numDeriv::grad(function(par) {
+     e <- matrix(par[seq_along(eta)], nrow = NROW(eta))
+     S <- matrix(nrow = NROW(Sigma), ncol = NCO .... [TRUNCATED] 

> do_comp_grad <- function(target_size, n_rep = 1, use_adaptive = FALSE, 
+     use_comb = FALSE) {
+     res <- if (use_comb) 
+         mixed_mult_l .... [TRUNCATED] 

> grad_cpp <- do_comp_grad(n_points, use_adaptive = TRUE)

> all.equal(do_comp(n_points, use_adaptive = TRUE), 
+     grad_cpp[1])
[1] TRUE

> all.equal(num_grad, grad_cpp[-1])
[1] "Mean relative difference: 0.001030137"

> grad_cpp_comb <- do_comp_grad(n_points, use_adaptive = TRUE, 
+     use_comb = TRUE)

> all.equal(grad_cpp, grad_cpp_comb)
[1] TRUE

> bench::mark(`GHQ1 adaptive` = do_comp_grad(target_size = n_points, 
+     use_adaptive = TRUE, n_rep = 1000), `GHQ2 adaptive` = do_comp_grad(target_ .... [TRUNCATED] 
[38;5;246m# A tibble: 3 Ã— 13[39m
  expression                 min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc
  [3m[38;5;246m<bch:expr>[39m[23m             [3m[38;5;246m<bch:t>[39m[23m [3m[38;5;246m<bch:>[39m[23m     [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<bch:byt>[39m[23m    [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<dbl>[39m[23m
[38;5;250m1[39m GHQ1 adaptive           19.3ms 19.9ms      49.9    5.12KB        0    25     0
[38;5;250m2[39m GHQ2 adaptive           19.1ms 19.3ms      51.6      200B        0    26     0
[38;5;250m3[39m GHQ2 adaptive combined  21.6ms 21.8ms      46.0    5.19KB        0    23     0
[38;5;246m# â€¦ with 5 more variables: total_time <bch:tm>, result <list>, memory <list>,[39m
[38;5;246m#   time <list>, gc <list>[39m

> set.seed(1)

> n_obs <- 2

> n <- 3

> Sigma <- as.matrix(drop(rWishart(1, 2 * n, diag(1/n, 
+     n))))

> eta <- matrix(runif(n_obs * n, -1), nrow = n)

> z <- runif(n, -1)

> probit_eta <- runif(1, -1)

> u <- drop(mvtnorm::rmvnorm(1, sigma = Sigma))

> lp <- eta + u

> p_hats <- rbind(1, exp(lp))/rep(1 + colSums(exp(lp)), 
+     each = n + 1)

> which_cat <- apply(p_hats, 2, function(x) sample.int(n + 
+     1, 1, prob = x))

> sign_probit <- drop((pnorm(probit_eta + z %*% u) > 
+     runif(1)))

> if (!sign_probit) {
+     z <- -z
+     probit_eta <- -probit_eta
+ }

> rm(u, lp, p_hats, sign_probit)

> brute_ests <- apply(mvtnorm::rmvnorm(1e+05, sigma = Sigma), 
+     1, function(u) {
+         exp_lp <- exp(eta + u)
+         denom <- 1 + colSums( .... [TRUNCATED] 

> se <- sd(brute_ests)/sqrt(length(brute_ests))

> brute_est <- mean(brute_ests)

> n_points <- 5

> ghq_dat <- fastGHQuad::gaussHermiteData(n_points)

> do_comp <- function(target_size, n_rep = 1, use_adaptive = FALSE) mixed_mult_logit_n_probit(eta = eta, 
+     Sigma = Sigma, which_category = which_ .... [TRUNCATED] 

> se/abs(brute_est)
[1] 0.005465469

> all.equal(do_comp(n_points), brute_est)
[1] "Mean relative difference: 0.01448755"

> log_integrand <- function(x) {
+     x <- drop(crossprod(chol(Sigma), x))
+     drop(pnorm(probit_eta + z %*% x, log.p = TRUE))
+ }

> log_integrand_cpp <- function(ders) mixed_probit_log_integrand(point = point, 
+     probit_eta = probit_eta, Sigma = Sigma, z = z, ders = ders)

> point <- runif(n, -1)

> all.equal(log_integrand(point), log_integrand_cpp(0))
[1] TRUE

> f <- log_integrand_cpp(1)[1]

> g <- log_integrand_cpp(1)[-1]

> all.equal(log_integrand(point), f)
[1] TRUE

> all.equal(numDeriv::grad(log_integrand, point), g)
[1] TRUE

> all.equal(c(numDeriv::hessian(log_integrand, point)), 
+     log_integrand_cpp(2))
[1] TRUE

> se/abs(brute_est)
[1] 0.005465469

> all.equal(do_comp(n_points, use_adaptive = TRUE), 
+     brute_est)
[1] "Mean relative difference: 0.0006243278"

> num_grad <- numDeriv::grad(function(par) {
+     e <- matrix(par[seq_along(eta)], nrow = NROW(eta))
+     par <- par[-seq_along(eta)]
+     e_prob < .... [TRUNCATED] 

> do_comp_grad <- function(target_size, n_rep = 1, use_adaptive = FALSE) {
+     res <- mixed_mult_logit_n_probit_grad(eta = eta, Sigma = Sigma, 
+    .... [TRUNCATED] 

> est <- do_comp_grad(n_points, use_adaptive = TRUE)

> all.equal(brute_est, est[1])
[1] "Mean relative difference: 0.0006247178"

> all.equal(num_grad, est[-1])
[1] "Mean relative difference: 0.002090637"

> bench::mark(Func = do_comp(target_size = n_points^2, 
+     n_rep = 1000), `Func adaptive` = do_comp(target_size = n_points^2, 
+     n_rep = 1000,  .... [TRUNCATED] 
[38;5;246m# A tibble: 4 Ã— 13[39m
  expression         min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc
  [3m[38;5;246m<bch:expr>[39m[23m    [3m[38;5;246m<bch:tm>[39m[23m [3m[38;5;246m<bch:tm>[39m[23m     [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<bch:byt>[39m[23m    [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<dbl>[39m[23m
[38;5;250m1[39m Func            14.1ms   14.5ms      68.1        0B        0    35     0
[38;5;250m2[39m Func adaptive     17ms   17.1ms      57.5        0B        0    29     0
[38;5;250m3[39m Grad            22.7ms   22.9ms      43.5    5.38KB        0    22     0
[38;5;250m4[39m Grad adaptive   25.6ms   26.2ms      37.8      392B        0    19     0
[38;5;246m# â€¦ with 5 more variables: total_time <bch:tm>, result <list>, memory <list>,[39m
[38;5;246m#   time <list>, gc <list>[39m

> etas <- c(-0.6381, -0.6343, -0.6285, -0.6227, -0.6193, 
+     -0.6212, -0.6313, -0.6515, -0.6827, -0.724, -0.7723, -0.8229, 
+     -0.8699, -0.9073, .... [TRUNCATED] 

> ws <- c(0.0473878636519986, 0.10842748431263, 0.165122315533235, 
+     0.215065333801771, 0.256205263034596, 0.286856653590245, 
+     0.3057643214 .... [TRUNCATED] 

> M <- structure(c(0.3115, 0.312, 0.3128, 0.3141, 0.3156, 
+     0.3173, 0.3192, 0.3212, 0.3232, 0.3251, 0.3269, 0.3284, 0.3296, 
+     0.3305, 0.331, .... [TRUNCATED] 

> V <- structure(c(0.35, 0.08, -0.05, 0.01, 0, 0.08, 
+     1.92, -0.24, -0.04, 0, -0.05, -0.24, 0.32, 0.09, 0, 0.01, 
+     -0.04, 0.09, 0.12, 0, 0,  .... [TRUNCATED] 

> n <- NCOL(V)

> brute_ests <- apply(mvtnorm::rmvnorm(1e+06, sigma = V), 
+     1, function(u) {
+         x <- drop(M %*% u)
+         exp(-sum(ws * exp(x + etas))) .... [TRUNCATED] 

> se <- sd(brute_ests)/sqrt(length(brute_ests))

> brute_est <- mean(brute_ests)

> n_points <- 2

> ghq_dat <- fastGHQuad::gaussHermiteData(n_points)

> do_comp <- function(target_size, n_rep = 1, use_adaptive = FALSE) expected_survival_term(eta = etas, 
+     ws = ws, M = M, Sigma = V, weights = ghq .... [TRUNCATED] 

> se/abs(brute_est)
[1] 0.0006613239

> all.equal(do_comp(n_points), brute_est)
[1] "Mean relative difference: 0.0007380613"

> log_integrand <- function(x) {
+     x <- crossprod(chol(V), x)
+     x <- drop(M %*% x)
+     -sum(ws * exp(x + etas))
+ }

> log_integrand_cpp <- function(ders) expected_survival_term_log_integrand(point = point, 
+     eta = etas, weights = ws, M = M, Sigma = V, ders = de .... [TRUNCATED] 

> point <- runif(n, -1)

> all.equal(log_integrand(point), log_integrand_cpp(0))
[1] TRUE

> f <- log_integrand_cpp(1)[1]

> g <- log_integrand_cpp(1)[-1]

> all.equal(log_integrand(point), f)
[1] TRUE

> all.equal(numDeriv::grad(log_integrand, point), g)
[1] TRUE

> all.equal(c(numDeriv::hessian(log_integrand, point)), 
+     log_integrand_cpp(2))
[1] TRUE

> se/abs(brute_est)
[1] 0.0006613239

> all.equal(do_comp(n_points, use_adaptive = TRUE), 
+     brute_est)
[1] "Mean relative difference: 6.538229e-07"

> bench::mark(GHQ1 = do_comp(target_size = n_points, 
+     use_adaptive = FALSE, n_rep = 1000), GHQ5 = do_comp(target_size = n_points^5, 
+     use_a .... [TRUNCATED] 
[38;5;246m# A tibble: 4 Ã— 13[39m
  expression         min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc
  [3m[38;5;246m<bch:expr>[39m[23m    [3m[38;5;246m<bch:tm>[39m[23m [3m[38;5;246m<bch:tm>[39m[23m     [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<bch:byt>[39m[23m    [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<dbl>[39m[23m
[38;5;250m1[39m GHQ1            5.09ms   5.22ms      192.        0B        0    96     0
[38;5;250m2[39m GHQ5            4.45ms   4.63ms      214.        0B        0   107     0
[38;5;250m3[39m GHQ1 adaptive   7.17ms   7.26ms      137.        0B        0    69     0
[38;5;250m4[39m GHQ5 adaptive   5.24ms   5.32ms      186.        0B        0    94     0
[38;5;246m# â€¦ with 5 more variables: total_time <bch:tm>, result <list>, memory <list>,[39m
[38;5;246m#   time <list>, gc <list>[39m

> num_grad <- numDeriv::grad(function(par) {
+     e <- par[seq_along(etas)]
+     par <- par[-seq_along(etas)]
+     M <- matrix(par[seq_along(M)], n .... [TRUNCATED] 

> do_comp_grad <- function(target_size, n_rep = 1, use_adaptive = FALSE) {
+     res <- expected_survival_term_grad(eta = etas, ws = ws, M = M, 
+     .... [TRUNCATED] 

> est <- do_comp_grad(n_points, use_adaptive = TRUE)

> all.equal(brute_est, est[1])
[1] "Mean relative difference: 6.538224e-07"

> all.equal(num_grad, est[-1])
[1] "Mean relative difference: 0.04125972"

> bench::mark(GHQ1 = do_comp_grad(target_size = n_points, 
+     use_adaptive = FALSE, n_rep = 1000), GHQ5 = do_comp_grad(target_size = n_points^5, 
+ .... [TRUNCATED] 
[38;5;246m# A tibble: 4 Ã— 13[39m
  expression         min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc
  [3m[38;5;246m<bch:expr>[39m[23m    [3m[38;5;246m<bch:tm>[39m[23m [3m[38;5;246m<bch:tm>[39m[23m     [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<bch:byt>[39m[23m    [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<dbl>[39m[23m
[38;5;250m1[39m GHQ1            13.8ms   14.1ms      70.8    8.44KB        0    36     0
[38;5;250m2[39m GHQ5            9.11ms   9.19ms     109.     3.48KB        0    55     0
[38;5;250m3[39m GHQ1 adaptive  19.44ms  19.57ms      51.0    3.48KB        0    26     0
[38;5;250m4[39m GHQ5 adaptive  11.15ms  11.31ms      87.9    3.48KB        0    44     0
[38;5;246m# â€¦ with 5 more variables: total_time <bch:tm>, result <list>, memory <list>,[39m
[38;5;246m#   time <list>, gc <list>[39m
> 
> 
