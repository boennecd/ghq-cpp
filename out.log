
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

* Project '~/Dropbox/skole_backup/postdoc/ghq-cpp' loaded. [renv 0.13.2]
> Rcpp::sourceCpp('ghq-cpp.cpp')

> set.seed(1)

> n <- 3

> Sigma <- as.matrix(drop(rWishart(1, 2 * n, diag(1/n, 
+     n))))

> mu <- rnorm(n)

> tval <- runif(n, -1)

> n_points <- 10

> ghq_dat <- fastGHQuad::gaussHermiteData(n_points)

> truth <- drop(exp(tval %*% mu + tval %*% Sigma %*% 
+     tval/2))

> do_comp <- function(target_size, n_rep = 1) mult_norm_moment(t = tval, 
+     mu = mu, Sigma = Sigma, weights = ghq_dat$w, nodes = ghq_dat$x, 
+     .... [TRUNCATED] 

> all.equal(do_comp(1), truth)
[1] "Mean relative difference: 1.075019e-07"

> all.equal(do_comp(n_points), truth)
[1] "Mean relative difference: 1.075019e-07"

> all.equal(do_comp(n_points^2), truth)
[1] "Mean relative difference: 1.075019e-07"

> bench::mark(GHQ1 = do_comp(target_size = n_points, 
+     n_rep = 1000), GHQ2 = do_comp(target_size = n_points^2, n_rep = 1000), 
+     GHQ2 = do_co .... [TRUNCATED] 
[38;5;246m# A tibble: 3 Ã— 13[39m
  expression     min  median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time
  [3m[38;5;246m<bch:expr>[39m[23m [3m[38;5;246m<bch:t>[39m[23m [3m[38;5;246m<bch:t>[39m[23m     [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<bch:byt>[39m[23m    [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<dbl>[39m[23m   [3m[38;5;246m<bch:tm>[39m[23m
[38;5;250m1[39m GHQ1       10.09ms 10.31ms      96.5        0B        0    49     0      508ms
[38;5;250m2[39m GHQ2       10.03ms 10.15ms      98.1        0B        0    50     0      510ms
[38;5;250m3[39m GHQ2        8.58ms  8.69ms     115.         0B        0    58     0      506ms
[38;5;246m# â€¦ with 4 more variables: result <list>, memory <list>, time <list>, gc <list>[39m

> set.seed(1)

> n_obs <- 3

> n <- 3

> Sigma <- as.matrix(drop(rWishart(1, 2 * n, diag(1/n, 
+     n))))

> eta <- matrix(runif(n_obs * n, -1), nrow = n)

> u <- drop(mvtnorm::rmvnorm(1, sigma = Sigma))

> lp <- eta + u

> p_hats <- rbind(1, exp(lp))/rep(1 + colSums(exp(lp)), 
+     each = n + 1)

> which_cat <- apply(p_hats, 2, function(x) sample.int(n + 
+     1, 1, prob = x))

> rm(u, lp, p_hats)

> brute_ests <- apply(mvtnorm::rmvnorm(1e+06, sigma = Sigma), 
+     1, function(u) {
+         exp_lp <- exp(eta + u)
+         denom <- 1 + colSums( .... [TRUNCATED] 

> se <- sd(brute_ests)/sqrt(length(brute_ests))

> brute_est <- mean(brute_ests)

> n_points <- 5

> ghq_dat <- fastGHQuad::gaussHermiteData(n_points)

> do_comp <- function(target_size, n_rep = 1, use_adaptive = FALSE) mixed_mult_logit_term(eta = eta, 
+     Sigma = Sigma, which_category = which_cat  .... [TRUNCATED] 

> se/abs(brute_est)
[1] 0.001534806

> all.equal(do_comp(n_points), brute_est)
[1] "Mean relative difference: 0.03265323"

> all.equal(do_comp(n_points^2), brute_est)
[1] "Mean relative difference: 0.03265323"

> all.equal(do_comp(n_points^3), brute_est)
[1] "Mean relative difference: 0.03265323"

> log_integrand <- function(x) {
+     x <- drop(crossprod(chol(Sigma), x))
+     exp_lp <- exp(eta + x)
+     denom <- 1 + colSums(exp_lp)
+     num  .... [TRUNCATED] 

> log_integrand_cpp <- function(ders) mixed_mult_logit_term_log_integrand(point = point, 
+     eta = eta, Sigma = Sigma, which_category = which_cat - .... [TRUNCATED] 

> point <- runif(n, -1)

> all.equal(log_integrand(point), log_integrand_cpp(0))
[1] TRUE

> f <- log_integrand_cpp(1)[1]

> g <- log_integrand_cpp(1)[-1]

> all.equal(log_integrand(point), f)
[1] TRUE

> all.equal(numDeriv::grad(log_integrand, point), g)
[1] TRUE

> all.equal(c(numDeriv::hessian(log_integrand, point)), 
+     log_integrand_cpp(2))
[1] TRUE

> se/abs(brute_est)
[1] 0.001534806

> all.equal(do_comp(n_points, use_adaptive = TRUE), 
+     brute_est)
[1] "Mean relative difference: 0.0005337538"

> all.equal(do_comp(n_points^2, use_adaptive = TRUE), 
+     brute_est)
[1] "Mean relative difference: 0.0005337538"

> all.equal(do_comp(n_points^3, use_adaptive = TRUE), 
+     brute_est)
[1] "Mean relative difference: 0.0005337538"

> bench::mark(GHQ1 = do_comp(target_size = n_points, 
+     use_adaptive = FALSE, n_rep = 1000), GHQ2 = do_comp(target_size = n_points^2, 
+     use_a .... [TRUNCATED] 
[38;5;246m# A tibble: 6 Ã— 13[39m
  expression         min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc
  [3m[38;5;246m<bch:expr>[39m[23m    [3m[38;5;246m<bch:tm>[39m[23m [3m[38;5;246m<bch:tm>[39m[23m     [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<bch:byt>[39m[23m    [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<dbl>[39m[23m
[38;5;250m1[39m GHQ1            8.96ms   9.19ms     108.         0B        0    54     0
[38;5;250m2[39m GHQ2            9.01ms   9.22ms     108.         0B        0    54     0
[38;5;250m3[39m GHQ3               8ms   8.27ms     121.         0B        0    61     0
[38;5;250m4[39m GHQ1 adaptive  12.03ms  12.25ms      81.3        0B        0    41     0
[38;5;250m5[39m GHQ2 adaptive  12.08ms  12.23ms      81.6        0B        0    41     0
[38;5;250m6[39m GHQ3 adaptive   9.87ms   9.99ms      96.9        0B        0    49     0
[38;5;246m# â€¦ with 5 more variables: total_time <bch:tm>, result <list>, memory <list>,[39m
[38;5;246m#   time <list>, gc <list>[39m

> num_grad <- numDeriv::grad(function(par) {
+     e <- matrix(par[seq_along(eta)], nrow = NROW(eta))
+     S <- matrix(nrow = NROW(Sigma), ncol = NCO .... [TRUNCATED] 

> do_comp_grad <- function(target_size, n_rep = 1, use_adaptive = FALSE, 
+     use_comb = FALSE) {
+     res <- if (use_comb) 
+         mixed_mult_l .... [TRUNCATED] 

> grad_cpp <- do_comp_grad(n_points, use_adaptive = TRUE)

> all.equal(do_comp(n_points, use_adaptive = TRUE), 
+     grad_cpp[1])
[1] TRUE

> all.equal(num_grad, grad_cpp[-1])
[1] "Mean relative difference: 0.001030137"

> grad_cpp_comb <- do_comp_grad(n_points, use_adaptive = TRUE, 
+     use_comb = TRUE)

> all.equal(grad_cpp, grad_cpp_comb)
[1] TRUE

> bench::mark(`GHQ1 adaptive` = do_comp_grad(target_size = n_points, 
+     use_adaptive = TRUE, n_rep = 1000), `GHQ2 adaptive` = do_comp_grad(target_ .... [TRUNCATED] 
[38;5;246m# A tibble: 3 Ã— 13[39m
  expression                 min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc
  [3m[38;5;246m<bch:expr>[39m[23m             [3m[38;5;246m<bch:t>[39m[23m [3m[38;5;246m<bch:>[39m[23m     [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<bch:byt>[39m[23m    [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<dbl>[39m[23m
[38;5;250m1[39m GHQ1 adaptive           19.2ms 19.3ms      49.3    5.12KB        0    25     0
[38;5;250m2[39m GHQ2 adaptive           19.2ms 19.3ms      51.2      200B        0    26     0
[38;5;250m3[39m GHQ2 adaptive combined  21.6ms 21.8ms      45.6    5.19KB        0    23     0
[38;5;246m# â€¦ with 5 more variables: total_time <bch:tm>, result <list>, memory <list>,[39m
[38;5;246m#   time <list>, gc <list>[39m

> set.seed(1)

> n_obs <- 2

> n <- 3

> Sigma <- as.matrix(drop(rWishart(1, 2 * n, diag(1/n, 
+     n))))

> eta <- matrix(runif(n_obs * n, -1), nrow = n)

> z <- runif(n, -1)

> probit_eta <- runif(1, -1)

> u <- drop(mvtnorm::rmvnorm(1, sigma = Sigma))

> lp <- eta + u

> p_hats <- rbind(1, exp(lp))/rep(1 + colSums(exp(lp)), 
+     each = n + 1)

> which_cat <- apply(p_hats, 2, function(x) sample.int(n + 
+     1, 1, prob = x))

> sign_probit <- drop((pnorm(probit_eta + z %*% u) > 
+     runif(1)))

> if (!sign_probit) {
+     z <- -z
+     probit_eta <- -probit_eta
+ }

> rm(u, lp, p_hats, sign_probit)

> brute_ests <- apply(mvtnorm::rmvnorm(1e+05, sigma = Sigma), 
+     1, function(u) {
+         exp_lp <- exp(eta + u)
+         denom <- 1 + colSums( .... [TRUNCATED] 

> se <- sd(brute_ests)/sqrt(length(brute_ests))

> brute_est <- mean(brute_ests)

> n_points <- 5

> ghq_dat <- fastGHQuad::gaussHermiteData(n_points)

> do_comp <- function(target_size, n_rep = 1, use_adaptive = FALSE) mixed_mult_logit_n_probit(eta = eta, 
+     Sigma = Sigma, which_category = which_ .... [TRUNCATED] 

> se/abs(brute_est)
[1] 0.005465469

> all.equal(do_comp(n_points), brute_est)
[1] "Mean relative difference: 0.01448755"

> log_integrand <- function(x) {
+     x <- drop(crossprod(chol(Sigma), x))
+     drop(pnorm(probit_eta + z %*% x, log.p = TRUE))
+ }

> log_integrand_cpp <- function(ders) mixed_probit_log_integrand(point = point, 
+     probit_eta = probit_eta, Sigma = Sigma, z = z, ders = ders)

> point <- runif(n, -1)

> all.equal(log_integrand(point), log_integrand_cpp(0))
[1] TRUE

> f <- log_integrand_cpp(1)[1]

> g <- log_integrand_cpp(1)[-1]

> all.equal(log_integrand(point), f)
[1] TRUE

> all.equal(numDeriv::grad(log_integrand, point), g)
[1] TRUE

> all.equal(c(numDeriv::hessian(log_integrand, point)), 
+     log_integrand_cpp(2))
[1] TRUE

> se/abs(brute_est)
[1] 0.005465469

> all.equal(do_comp(n_points, use_adaptive = TRUE), 
+     brute_est)
[1] "Mean relative difference: 0.0006243278"

> num_grad <- numDeriv::grad(function(par) {
+     e <- matrix(par[seq_along(eta)], nrow = NROW(eta))
+     par <- par[-seq_along(eta)]
+     e_prob < .... [TRUNCATED] 

> do_comp_grad <- function(target_size, n_rep = 1, use_adaptive = FALSE) {
+     res <- mixed_mult_logit_n_probit_grad(eta = eta, Sigma = Sigma, 
+    .... [TRUNCATED] 

> est <- do_comp_grad(n_points, use_adaptive = TRUE)

> all.equal(brute_est, est[1])
[1] "Mean relative difference: 0.0006247178"

> all.equal(num_grad, est[-1])
[1] "Mean relative difference: 0.002090637"

> bench::mark(Func = do_comp(target_size = n_points^2, 
+     n_rep = 1000), `Func adaptive` = do_comp(target_size = n_points^2, 
+     n_rep = 1000,  .... [TRUNCATED] 
[38;5;246m# A tibble: 4 Ã— 13[39m
  expression         min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc
  [3m[38;5;246m<bch:expr>[39m[23m    [3m[38;5;246m<bch:tm>[39m[23m [3m[38;5;246m<bch:tm>[39m[23m     [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<bch:byt>[39m[23m    [3m[38;5;246m<dbl>[39m[23m [3m[38;5;246m<int>[39m[23m [3m[38;5;246m<dbl>[39m[23m
[38;5;250m1[39m Func            13.9ms   14.2ms      70.0        0B        0    35     0
[38;5;250m2[39m Func adaptive   16.6ms   16.9ms      59.2        0B        0    30     0
[38;5;250m3[39m Grad            22.5ms   22.7ms      43.8    5.38KB        0    22     0
[38;5;250m4[39m Grad adaptive   25.4ms   25.8ms      38.6      392B        0    20     0
[38;5;246m# â€¦ with 5 more variables: total_time <bch:tm>, result <list>, memory <list>,[39m
[38;5;246m#   time <list>, gc <list>[39m
> 
> 
