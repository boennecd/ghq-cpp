
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(mvtnorm)
> library(ghqCpp)
> 
> # compute relative errors for different configurations with the two
> # implementations
> comp_errors <- \(method)
+ sapply(seq_len(1e4), \(i){
+   set.seed(i)
+   truth <- -Inf
+   while(!is.finite(truth) || truth < 1e-12){
+     Sigma <- rWishart(1, 2, diag(2)) |> drop()
+     mu <- rnorm(2)
+     truth <- pmvnorm(upper = numeric(2), mean = mu, sigma = Sigma)
+   }
+ 
+   # compute the error and return
+   if(mu[1] > 0 && mu[2] < 0 && Sigma[1,2] < 0){
+     A <- pnorm(mu[1] / sqrt(Sigma[1, 1]))
+     tmp <- Sigma
+     tmp[1, 2] <- tmp[2, 1] <- -tmp[2, 1]
+     B <- pbvn(c(mu[1], -mu[2]), tmp, method = method)
+     est <- 1 - A - B
+ 
+   } else if(mu[1] < 0 && mu[2] > 0 && Sigma[1,2] < 0){
+     A <- pnorm(mu[2] / sqrt(Sigma[2, 2]))
+     tmp <- Sigma
+     tmp[1, 2] <- tmp[2, 1] <- -tmp[2, 1]
+     B <- pbvn(c(-mu[1], mu[2]), tmp, method = method)
+     est <- 1 - A - B
+ 
+   } else if(Sigma[1,2] < 0){
+     mu_std <- mu / sqrt(diag(Sigma))
+ 
+     tmp <- Sigma
+     tmp[1, 2] <- tmp[2, 1] <- -tmp[2, 1]
+     if(mu_std[1] > mu_std[2]){
+       A <- pbvn(c(mu[1], -mu[2]), tmp, method = method)
+       B <- pnorm(mu[1] / sqrt(Sigma[1, 1]))
+       est <- 1 - A - B
+ 
+     } else {
+       A <- pbvn(c(-mu[1], mu[2]), tmp, method = method)
+       B <- pnorm(mu[2] / sqrt(Sigma[2, 2]))
+       est <- 1 - A - B
+     }
+   } else
+     est <- pbvn(mu, Sigma, method = method)
+ 
+   c(absolute = est - truth, relative = (est - truth) / truth, truth = truth)
+ }, simplify = "array")
> 
> errs_method0 <- comp_errors(0)
> errs_method1 <- comp_errors(1)
> errs_method2 <- comp_errors(2)
> 
> # look at stats for the absolute errors
> abs(errs_method0[c("absolute", "relative"), ]) |>
+   apply(1, quantile,
+         probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
          absolute     relative
0%    0.000000e+00 0.000000e+00
5%    1.922934e-17 2.722972e-16
10%   8.326673e-17 6.862054e-16
15%   1.387779e-16 8.311175e-16
20%   2.220446e-16 9.209232e-16
25%   3.230922e-16 1.104925e-15
30%   4.440892e-16 5.067638e-15
35%   6.661338e-16 1.323275e-13
40%   1.892236e-14 3.946146e-12
45%   1.259480e-12 7.215485e-11
50%   2.231793e-11 7.009689e-10
55%   1.806269e-10 4.614876e-09
60%   1.706358e-09 3.580117e-08
65%   1.000738e-08 1.661387e-07
70%   3.725718e-08 4.513897e-07
75%   9.075721e-08 9.508968e-07
80%   1.834370e-07 1.692873e-06
85%   3.278779e-07 2.777587e-06
90%   5.198873e-07 4.667453e-06
95%   8.714072e-07 7.601832e-06
99%   1.356756e-06 1.046408e-05
99.9% 1.655097e-06 3.697208e-05
100%  1.729089e-06 6.809305e-05
> abs(errs_method1[c("absolute", "relative"), ]) |>
+   apply(1, quantile,
+         probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
          absolute     relative
0%    0.000000e+00 0.000000e+00
5%    0.000000e+00 0.000000e+00
10%   0.000000e+00 0.000000e+00
15%   0.000000e+00 0.000000e+00
20%   0.000000e+00 0.000000e+00
25%   0.000000e+00 0.000000e+00
30%   0.000000e+00 0.000000e+00
35%   8.673617e-19 1.173371e-16
40%   1.387779e-17 1.409677e-16
45%   2.341877e-17 1.691030e-16
50%   2.775558e-17 1.981849e-16
55%   4.008007e-17 2.362331e-16
60%   5.551115e-17 3.086545e-16
65%   5.551115e-17 3.865022e-16
70%   5.551115e-17 4.963147e-16
75%   8.326673e-17 6.510961e-16
80%   1.110223e-16 9.074093e-16
85%   1.110223e-16 1.665037e-15
90%   1.110223e-16 5.440159e-15
95%   1.665335e-16 1.775102e-13
99%   2.220446e-16 1.011404e-08
99.9% 8.881784e-16 8.742874e-06
100%  1.821109e-15 5.821336e-05
> abs(errs_method2[c("absolute", "relative"), ]) |>
+   apply(1, quantile,
+         probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
          absolute     relative
0%    0.000000e+00 0.000000e+00
5%    5.551115e-17 5.616849e-16
10%   3.203416e-16 1.225371e-15
15%   1.554312e-15 5.798539e-14
20%   1.364157e-12 1.308497e-10
25%   1.003389e-10 5.978908e-09
30%   1.452851e-09 4.965035e-08
35%   7.255368e-09 1.863672e-07
40%   2.449404e-08 4.595550e-07
45%   5.923407e-08 9.077357e-07
50%   1.228748e-07 1.485431e-06
55%   2.237953e-07 2.336178e-06
60%   3.520032e-07 3.378106e-06
65%   5.195895e-07 4.576333e-06
70%   7.328062e-07 5.909382e-06
75%   9.779489e-07 7.512807e-06
80%   1.235491e-06 9.057373e-06
85%   1.568498e-06 1.434175e-05
90%   1.903219e-06 2.974800e-05
95%   2.368044e-06 5.982797e-05
99%   3.083484e-06 1.073379e-04
99.9% 3.746692e-06 1.422102e-04
100%  4.000544e-06 1.507206e-04
> 
> # compare the computation time
> set.seed(1)
> Sigma <- rWishart(1, 2, diag(2)) |> drop()
> mu <- rnorm(2)
> 
> bench::mark(
+   `pbvn method 0` = pbvn(mu, Sigma, method = 0),
+   `pbvn method 1` = pbvn(mu, Sigma, method = 1),
+   `pbvn method 2` = pbvn(mu, Sigma, method = 2),
+   check = FALSE)
# A tibble: 3 × 13
  expression         min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc
  <bch:expr>    <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>
1 pbvn method 0   6.95µs   7.09µs   136711.        0B     0    10000     0
2 pbvn method 1   1.27µs   1.41µs   577055.        0B    57.7   9999     1
3 pbvn method 2  11.73µs  12.17µs    80199.        0B     8.02  9999     1
# … with 5 more variables: total_time <bch:tm>, result <list>, memory <list>,
#   time <list>, gc <list>
> 
> # # check the time to do a 1000 evaluations (assuming that the optimizer does not
> # # do something crazy)
> # bench::mark(`pbvn method 0` = pbvn(mu, Sigma, n_rep = 1000, method = 0),
> #             `pbvn method 1` = pbvn(mu, Sigma, n_rep = 1000, method = 1),
> #             pmvnorm_C(mu = mu, Sigma = Sigma, n_rep = 1000))
> #
> # # check the gradient
> # library(numDeriv)
> # errs <- sapply(seq_len(1e4), \(i){
> #   set.seed(i)
> #   truth <- -Inf
> #   while(!is.finite(truth) || truth < 1e-12){
> #     Sigma <- rWishart(1, 2, diag(2)) |> drop()
> #     mu <- rnorm(2)
> #     truth <- pmvnorm(upper = numeric(2), mean = mu, sigma = Sigma)
> #   }
> #
> #   # compute the gradient numerically of the log of the interval
> #   fn <- pmvnorm(upper = numeric(2), mean = mu, sigma = Sigma)
> #   num_grad <- grad(
> #     \(par) {
> #       mu <- head(par, 2)
> #       S <- matrix(nrow = 2, ncol = 2)
> #       S[upper.tri(S, TRUE)] <- tail(par, 3)
> #       S[lower.tri(S)] <- t(S)[lower.tri(S)]
> #
> #       pmvnorm_C(mu = mu, Sigma = S)
> #     }, c(mu, Sigma[upper.tri(Sigma, TRUE)]), method.args = list(r = 6))
> #
> #   # compute the gradient, compute the error and return
> #   est <- pbvn_grad(mu = mu, Sigma = Sigma)
> #
> #   # only keep the upper triangle
> #   d_Sig <- tail(est, 4) |> matrix(nrow = 2)
> #   d_Sig[upper.tri(d_Sig)] <- 2 * d_Sig[upper.tri(d_Sig)]
> #   val <- attr(est, "value")
> #   est <- c(val, c(head(est, 2), d_Sig[upper.tri(d_Sig, TRUE)]) / val)
> #
> #   truth <- c(fn, num_grad / fn) |>
> #     setNames(c("integral", "d mu1", "d mu2", "d Sig11", "d Sig12",
> #                "d Sig22"))
> #   err <- est - truth
> #   relative = ifelse(abs(truth) < 1e-12, err, err / abs(truth))
> #
> #   cbind(absolute = err, relative = relative, truth = truth, est,
> #         rho = cov2cor(Sigma)[1, 2])
> # }, simplify = "array")
> #
> # # quantiles of the absolute error
> # apply(abs(errs[, "absolute", ]),
> #       1, quantile, probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
> #
> # # quantiles of the relative error
> # apply(abs(errs[, "relative", ]),
> #       1, quantile, probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
> #
> # # check the computation time for 1000 evaluations
> # bench::mark(pbvn_grad(mu = mu, Sigma = Sigma, n_rep = 1000))
> #
> # # plot the errors versus the integral value
> # vals <- errs["integral", "truth", ]
> #
> # par(mar = c(5, 5, 1, 1))
> # plot(vals, errs["d mu1", "relative", ], type = "h")
> # plot(vals, errs["d Sig12", "relative", ], type = "h")
> # plot(vals, errs["d mu1", "absolute", ], type = "h")
> # plot(vals, errs["d Sig12", "absolute", ], type = "h")
> #
> # rhos <- errs["integral", "rho", ]
> # plot(rhos, errs["d mu1", "relative", ], type = "h")
> # plot(rhos, errs["d Sig12", "relative", ], type = "h")
> #
> # # may fail with a large absolute correlation coefficient
> # plot(rhos, errs["integral", "absolute", ], type = "h")
> # plot(rhos, errs["d mu1", "absolute", ], type = "h")
> # plot(rhos, errs["d mu2", "absolute", ], type = "h")
> # plot(rhos, errs["d Sig11", "absolute", ], type = "h")
> # plot(rhos, errs["d Sig12", "absolute", ], type = "h")
> # plot(rhos, errs["d Sig22", "absolute", ], type = "h")
> #
> #
> # local({
> #   keep <- abs(rhos) < .99
> #   rhos <- rhos[keep]
> #   errs <- errs[, , keep]
> #
> #   plot(rhos, errs["integral", "absolute", ], type = "h")
> #   plot(rhos, errs["d mu1", "absolute", ], type = "h")
> #   plot(rhos, errs["d mu2", "absolute", ], type = "h")
> #   plot(rhos, errs["d Sig11", "absolute", ], type = "h")
> #   plot(rhos, errs["d Sig12", "absolute", ], type = "h")
> #   plot(rhos, errs["d Sig22", "absolute", ], type = "h")
> # })
> 
> proc.time()
   user  system elapsed 
  8.739   0.060   8.798 
