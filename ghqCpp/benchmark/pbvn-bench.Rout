
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(mvtnorm)
> library(ghqCpp)
> 
> # compute relative errors for different configurations with the two
> # implementations
> comp_errors <- \(method)
+ sapply(seq_len(1e4), \(i){
+   set.seed(i)
+   truth <- -Inf
+   while(!is.finite(truth) || truth < 1e-12){
+     Sigma <- rWishart(1, 2, diag(2)) |> drop()
+     mu <- rnorm(2)
+     truth <- pmvnorm(upper = numeric(2), mean = mu, sigma = Sigma)
+   }
+ 
+   # compute the error and return
+   est <- pbvn(mu, Sigma, method = method)
+   c(absolute = est - truth, relative = (est - truth) / truth, truth = truth)
+ }, simplify = "array")
> 
> errs_method0 <- comp_errors(0)
> errs_method1 <- comp_errors(1)
> 
> # look at stats for the absolute errors
> abs(errs_method0[c("absolute", "relative"), ]) |>
+   apply(1, quantile,
+         probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
          absolute     relative
0%    0.000000e+00 0.000000e+00
5%    2.077331e-17 2.823690e-16
10%   7.913783e-17 6.271763e-16
15%   1.387779e-16 7.067038e-16
20%   2.220446e-16 8.209196e-16
25%   2.775558e-16 1.006444e-15
30%   3.885781e-16 4.829078e-15
35%   5.551115e-16 1.312518e-13
40%   1.889322e-14 3.974367e-12
45%   1.259465e-12 7.187981e-11
50%   2.231795e-11 7.014727e-10
55%   1.806270e-10 4.592123e-09
60%   1.706358e-09 3.530954e-08
65%   1.000738e-08 1.659283e-07
70%   3.725718e-08 4.492362e-07
75%   9.075721e-08 9.453733e-07
80%   1.834370e-07 1.688521e-06
85%   3.278779e-07 2.768548e-06
90%   5.198873e-07 4.645308e-06
95%   8.714072e-07 7.595871e-06
99%   1.356756e-06 1.042974e-05
99.9% 1.655097e-06 3.348852e-05
100%  1.729089e-06 6.809305e-05
> abs(errs_method1[c("absolute", "relative"), ]) |>
+   apply(1, quantile,
+         probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
          absolute     relative
0%    0.000000e+00 0.000000e+00
5%    0.000000e+00 0.000000e+00
10%   0.000000e+00 0.000000e+00
15%   0.000000e+00 0.000000e+00
20%   0.000000e+00 0.000000e+00
25%   0.000000e+00 0.000000e+00
30%   0.000000e+00 0.000000e+00
35%   0.000000e+00 0.000000e+00
40%   0.000000e+00 0.000000e+00
45%   1.084202e-19 1.229525e-16
50%   5.204170e-18 1.513187e-16
55%   1.387779e-17 1.826808e-16
60%   2.775558e-17 2.181413e-16
65%   3.122502e-17 2.943434e-16
70%   5.551115e-17 3.824212e-16
75%   5.551115e-17 5.075301e-16
80%   6.938894e-17 6.792761e-16
85%   1.110223e-16 1.040883e-15
90%   1.110223e-16 2.443817e-15
95%   1.387779e-16 1.342813e-14
99%   2.220446e-16 1.368444e-12
99.9% 2.775558e-16 1.830769e-08
100%  6.255847e-16 3.419518e-07
> 
> # compare the computation time
> set.seed(1)
> Sigma <- rWishart(1, 2, diag(2)) |> drop()
> mu <- rnorm(2)
> 
> bench::mark(
+   `pbvn method 0` = pbvn(mu, Sigma, method = 0),
+   `pbvn method 1` = pbvn(mu, Sigma, method = 1),
+   check = FALSE)
# A tibble: 2 × 13
  expression         min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc
  <bch:expr>    <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>
1 pbvn method 0   6.37µs   6.61µs   144252.        0B     14.4  9999     1
2 pbvn method 1   1.38µs   1.48µs   612407.        0B      0   10000     0
# … with 5 more variables: total_time <bch:tm>, result <list>, memory <list>,
#   time <list>, gc <list>
> 
> # more extreme
> comp_errors_extreme <- \(method)
+ sapply(seq_len(1e4), \(i){
+   set.seed(i)
+   truth <- -Inf
+   while(!is.finite(truth) || truth > 1e-12 && truth < 1e-34){
+     Sigma <- rWishart(1, 2, diag(2)) |> drop()
+     mu <- rnorm(2)
+     truth <- pmvnorm(upper = numeric(2), mean = mu, sigma = Sigma)
+   }
+ 
+   # compute the error and return
+   est <- pbvn(mu, Sigma, method = method)
+ 
+   c(absolute = est - truth, relative = (est - truth) / (truth + 1e-100),
+     truth = truth)
+ }, simplify = "array")
> 
> errs_method_extreme <- comp_errors_extreme(1)
> 
> abs(errs_method_extreme[c("absolute", "relative"), ]) |>
+   apply(1, quantile,
+         probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
          absolute     relative
0%    0.000000e+00 0.000000e+00
5%    0.000000e+00 0.000000e+00
10%   0.000000e+00 0.000000e+00
15%   0.000000e+00 0.000000e+00
20%   0.000000e+00 0.000000e+00
25%   0.000000e+00 0.000000e+00
30%   0.000000e+00 0.000000e+00
35%   0.000000e+00 0.000000e+00
40%   0.000000e+00 0.000000e+00
45%   8.271806e-25 1.220687e-16
50%   1.734723e-18 1.514247e-16
55%   1.040834e-17 1.849801e-16
60%   2.775558e-17 2.220557e-16
65%   2.775558e-17 3.082544e-16
70%   5.551115e-17 3.980947e-16
75%   5.551115e-17 5.434732e-16
80%   6.245005e-17 7.567882e-16
85%   1.110223e-16 1.246516e-15
90%   1.110223e-16 3.471977e-15
95%   1.387779e-16 4.756150e-14
99%   2.220446e-16 1.921361e-10
99.9% 2.775558e-16 7.692949e-02
100%  6.255847e-16 7.000000e+00
> 
> # check the gradient
> library(numDeriv)
> comp_errors_grad <- \(method)
+   sapply(seq_len(1e4), \(i){
+     set.seed(i)
+     truth <- -Inf
+     while(!is.finite(truth) || truth < 1e-12){
+       Sigma <- rWishart(1, 2, diag(2)) |> drop()
+       mu <- rnorm(2)
+       truth <- pmvnorm(upper = numeric(2), mean = mu, sigma = Sigma)
+     }
+ 
+     # compute the gradient numerically of the log of the interval
+     fn <- pmvnorm(upper = numeric(2), mean = mu, sigma = Sigma)
+     num_grad <- grad(
+       \(par) {
+         mu <- head(par, 2)
+         S <- matrix(nrow = 2, ncol = 2)
+         S[upper.tri(S, TRUE)] <- tail(par, 3)
+         S[lower.tri(S)] <- t(S)[lower.tri(S)]
+ 
+         pmvnorm(upper = numeric(2), mean = mu, sigma = S)
+       }, c(mu, Sigma[upper.tri(Sigma, TRUE)]), method.args = list(r = 6))
+ 
+     # compute the gradient, compute the error and return
+     est <- pbvn_grad(mu = mu, Sigma = Sigma, method = method)
+ 
+     # only keep the upper triangle
+     d_Sig <- tail(est, 4) |> matrix(nrow = 2)
+     d_Sig[upper.tri(d_Sig)] <- 2 * d_Sig[upper.tri(d_Sig)]
+     val <- attr(est, "prob")
+     est <- c(val, c(head(est, 2), d_Sig[upper.tri(d_Sig, TRUE)]) / val)
+ 
+     truth <- c(fn, num_grad / fn) |>
+       setNames(c("integral", "d mu1", "d mu2", "d Sig11", "d Sig12",
+                  "d Sig22"))
+     err <- est - truth
+     relative = ifelse(abs(truth) < 1e-12, err, err / abs(truth))
+ 
+     cbind(absolute = err, relative = relative, truth = truth, est,
+           rho = cov2cor(Sigma)[1, 2], mu_std1 = mu[1] / sqrt(Sigma[1, 1]),
+           mu_std2 = mu[2] / sqrt(Sigma[2, 2]))
+   }, simplify = "array")
> 
> errs_grad_method0 <- comp_errors_grad(0)
> errs_grad_method1 <- comp_errors_grad(1)
> 
> # quantiles of the absolute error
> apply(abs(errs_grad_method0[, "absolute", ]),
+       1, quantile, probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
          integral        d mu1        d mu2      d Sig11      d Sig12
0%    0.000000e+00 0.000000e+00 0.000000e+00 7.042189e-16 9.983656e-19
5%    0.000000e+00 4.652314e-12 6.083862e-12 3.734148e-12 7.473129e-14
10%   0.000000e+00 3.029277e-11 3.326520e-11 2.320260e-11 1.980805e-12
15%   0.000000e+00 1.437553e-10 1.656789e-10 1.406007e-10 7.038042e-12
20%   0.000000e+00 9.974768e-10 1.045756e-09 1.323656e-09 1.532245e-11
25%   0.000000e+00 7.287903e-09 8.437640e-09 1.067831e-08 3.152269e-11
30%   0.000000e+00 6.178238e-08 6.494578e-08 7.669686e-08 8.077948e-11
35%   0.000000e+00 4.235678e-07 4.089190e-07 3.992112e-07 3.952326e-10
40%   2.585747e-25 1.373369e-06 1.291361e-06 1.192191e-06 2.257188e-09
45%   1.734723e-18 3.109148e-06 2.865855e-06 3.168916e-06 1.345869e-08
50%   1.040834e-17 6.011022e-06 5.791856e-06 8.342434e-06 7.828857e-08
55%   2.081668e-17 1.066750e-05 1.050203e-05 2.155989e-05 3.947834e-07
60%   2.775558e-17 1.836926e-05 1.773648e-05 4.074306e-05 1.202659e-06
65%   5.551115e-17 2.614936e-05 2.574165e-05 6.210928e-05 2.680148e-06
70%   5.551115e-17 3.332183e-05 3.247395e-05 9.015596e-05 4.778337e-06
75%   5.551115e-17 4.076783e-05 3.963489e-05 1.220974e-04 8.250382e-06
80%   8.326673e-17 4.883420e-05 4.847598e-05 1.667799e-04 1.317467e-05
85%   1.110223e-16 6.011115e-05 6.034898e-05 2.435723e-04 2.041677e-05
90%   1.110223e-16 7.729593e-05 7.841077e-05 3.903032e-04 3.301818e-05
95%   1.665335e-16 1.134025e-04 1.160260e-04 8.221759e-04 6.961631e-05
99%   2.220446e-16 2.760829e-04 2.838343e-04 5.621064e-03 7.927988e-04
99.9% 3.053391e-16 2.044632e-01 2.494259e-01 6.264144e+02 2.793756e+04
100%  6.255847e-16 5.466099e+00 1.514324e+01 3.775189e+05 1.153060e+06
           d Sig22
0%    1.489803e-16
5%    3.791049e-12
10%   2.503907e-11
15%   1.470146e-10
20%   1.338440e-09
25%   1.223787e-08
30%   8.083392e-08
35%   3.723719e-07
40%   1.088935e-06
45%   2.693638e-06
50%   7.725128e-06
55%   2.048098e-05
60%   4.071536e-05
65%   6.052653e-05
70%   8.580702e-05
75%   1.175377e-04
80%   1.657665e-04
85%   2.456180e-04
90%   4.007529e-04
95%   8.987263e-04
99%   5.078585e-03
99.9% 4.006217e+02
100%  7.263380e+06
> apply(abs(errs_grad_method1[, "absolute", ]),
+       1, quantile, probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
          integral        d mu1        d mu2      d Sig11      d Sig12
0%    0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00
5%    0.000000e+00 1.136459e-12 1.251493e-12 5.670131e-13 0.000000e+00
10%   0.000000e+00 4.578052e-12 4.437883e-12 1.773735e-12 7.939262e-13
15%   0.000000e+00 8.141068e-12 8.430379e-12 3.273572e-12 2.805578e-12
20%   0.000000e+00 1.198631e-11 1.220455e-11 4.888866e-12 5.191769e-12
25%   0.000000e+00 1.638471e-11 1.660518e-11 6.674286e-12 7.977149e-12
30%   0.000000e+00 2.116184e-11 2.128983e-11 8.681678e-12 1.103171e-11
35%   0.000000e+00 2.712078e-11 2.665958e-11 1.100967e-11 1.459897e-11
40%   0.000000e+00 3.355596e-11 3.309072e-11 1.397450e-11 1.883558e-11
45%   1.626303e-19 4.090434e-11 4.081662e-11 1.760648e-11 2.384687e-11
50%   6.071532e-18 5.063770e-11 5.003659e-11 2.198895e-11 3.067682e-11
55%   1.387779e-17 6.175317e-11 6.166398e-11 2.820812e-11 3.925477e-11
60%   2.775558e-17 7.630603e-11 7.524043e-11 3.631326e-11 4.915786e-11
65%   3.168039e-17 9.562616e-11 9.374018e-11 4.683017e-11 6.471775e-11
70%   5.551115e-17 1.184274e-10 1.196965e-10 6.415004e-11 8.898678e-11
75%   5.551115e-17 1.565450e-10 1.601894e-10 9.134735e-11 1.296033e-10
80%   6.938894e-17 2.262304e-10 2.308893e-10 1.445850e-10 2.000566e-10
85%   1.110223e-16 3.743157e-10 3.591377e-10 2.564929e-10 3.586195e-10
90%   1.110223e-16 8.769657e-10 7.542273e-10 7.214842e-10 8.707208e-10
95%   1.387779e-16 4.770243e-09 4.047030e-09 7.106351e-09 7.479487e-09
99%   2.220446e-16 2.005712e-05 1.159130e-05 1.219203e-03 1.551758e-03
99.9% 2.775796e-16 1.185924e-02 5.377434e-03 6.264144e+02 2.793756e+04
100%  8.517492e-16 2.041841e-01 2.458811e-01 3.775189e+05 1.153060e+06
           d Sig22
0%    0.000000e+00
5%    5.275308e-13
10%   1.756789e-12
15%   3.191480e-12
20%   4.803979e-12
25%   6.504195e-12
30%   8.525197e-12
35%   1.073971e-11
40%   1.359631e-11
45%   1.706015e-11
50%   2.194522e-11
55%   2.776726e-11
60%   3.549387e-11
65%   4.672745e-11
70%   6.219026e-11
75%   9.045033e-11
80%   1.465581e-10
85%   2.752389e-10
90%   7.264356e-10
95%   6.965233e-09
99%   2.043887e-03
99.9% 4.006217e+02
100%  7.263380e+06
> 
> # quantiles of the relative error
> apply(abs(errs_grad_method0[, "relative", ]),
+       1, quantile, probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
          integral        d mu1        d mu2      d Sig11      d Sig12
0%    0.000000e+00 0.000000e+00 0.000000e+00 7.042189e-16 9.983656e-19
5%    0.000000e+00 2.486466e-11 2.500295e-11 2.118479e-11 7.723893e-14
10%   0.000000e+00 1.543645e-10 1.636254e-10 8.451216e-11 1.013316e-11
15%   0.000000e+00 6.968958e-10 7.998959e-10 3.395108e-10 3.574269e-11
20%   0.000000e+00 4.015690e-09 4.698928e-09 5.348015e-09 7.659152e-11
25%   0.000000e+00 3.820854e-08 4.277978e-08 7.380641e-08 2.535468e-10
30%   0.000000e+00 4.468375e-07 3.971060e-07 9.590109e-07 1.577459e-09
35%   0.000000e+00 1.836025e-06 1.720370e-06 3.892349e-06 7.318960e-09
40%   1.116584e-16 4.336825e-06 4.058606e-06 9.555144e-06 3.631535e-08
45%   1.374128e-16 7.262929e-06 6.976837e-06 1.751963e-05 2.427829e-07
50%   1.633939e-16 9.838554e-06 9.630875e-06 3.346130e-05 1.227808e-06
55%   1.935802e-16 1.425350e-05 1.371355e-05 6.952553e-05 3.364990e-06
60%   2.313186e-16 2.326414e-05 2.245587e-05 1.423297e-04 6.875797e-06
65%   3.111579e-16 3.434999e-05 3.401712e-05 2.788235e-04 1.047545e-05
70%   3.944973e-16 4.428709e-05 4.374170e-05 4.845131e-04 1.465147e-05
75%   5.215076e-16 5.411434e-05 5.337578e-05 8.201916e-04 1.931304e-05
80%   6.918828e-16 6.420058e-05 6.316718e-05 1.327269e-03 2.574240e-05
85%   1.047311e-15 7.706613e-05 7.600901e-05 1.936097e-03 3.456690e-05
90%   2.443817e-15 9.848020e-05 9.656036e-05 3.230405e-03 5.379870e-05
95%   1.342813e-14 1.406136e-04 1.354891e-04 7.807948e-03 3.081018e-04
99%   1.368444e-12 1.003888e-02 9.926030e-03 1.310886e-01 1.000000e+00
99.9% 1.830769e-08 1.000000e+00 1.000005e+00 3.663448e+01 2.013237e+03
100%  3.419518e-07 2.938602e+00 2.020181e+01 1.074913e+03 1.127653e+08
           d Sig22
0%    1.489803e-16
5%    2.060745e-11
10%   8.587881e-11
15%   3.295108e-10
20%   5.155380e-09
25%   7.587090e-08
30%   8.825686e-07
35%   3.813131e-06
40%   9.376032e-06
45%   1.706469e-05
50%   3.168835e-05
55%   6.633312e-05
60%   1.446715e-04
65%   2.754710e-04
70%   4.724265e-04
75%   8.105494e-04
80%   1.307708e-03
85%   1.904768e-03
90%   3.045559e-03
95%   7.530431e-03
99%   2.592348e-01
99.9% 1.761120e+01
100%  5.265625e+02
> apply(abs(errs_grad_method1[, "relative", ]),
+       1, quantile, probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
          integral        d mu1        d mu2      d Sig11      d Sig12
0%    0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00
5%    0.000000e+00 2.448280e-12 2.726810e-12 4.457965e-12 0.000000e+00
10%   0.000000e+00 9.611556e-12 9.705232e-12 1.474279e-11 2.966302e-12
15%   0.000000e+00 1.609343e-11 1.690817e-11 2.603645e-11 1.103207e-11
20%   0.000000e+00 2.381863e-11 2.470655e-11 3.785590e-11 1.929625e-11
25%   0.000000e+00 3.175359e-11 3.225692e-11 5.035788e-11 2.831112e-11
30%   0.000000e+00 4.087548e-11 4.051228e-11 6.367183e-11 3.782803e-11
35%   0.000000e+00 5.134113e-11 5.015867e-11 7.809985e-11 4.786594e-11
40%   0.000000e+00 6.191291e-11 6.134907e-11 9.316510e-11 5.881962e-11
45%   1.241426e-16 7.661859e-11 7.558481e-11 1.107636e-10 7.483509e-11
50%   1.526472e-16 9.315693e-11 9.231719e-11 1.328675e-10 9.339929e-11
55%   1.835849e-16 1.124771e-10 1.109315e-10 1.580348e-10 1.162616e-10
60%   2.198461e-16 1.382311e-10 1.345535e-10 1.884704e-10 1.532724e-10
65%   2.971126e-16 1.730116e-10 1.669648e-10 2.269840e-10 2.105300e-10
70%   3.851592e-16 2.218655e-10 2.108413e-10 2.809204e-10 3.296851e-10
75%   5.096537e-16 3.111386e-10 2.840287e-10 3.591152e-10 5.633342e-10
80%   6.950923e-16 4.703593e-10 4.236260e-10 4.948694e-10 1.249117e-09
85%   1.052691e-15 8.597297e-10 7.887896e-10 8.550915e-10 3.986286e-09
90%   2.469787e-15 2.942463e-09 2.596043e-09 2.247821e-09 3.768142e-08
95%   1.371818e-14 6.212597e-08 6.992492e-08 5.081229e-08 9.145275e-06
99%   1.368444e-12 5.298461e-04 3.211707e-04 5.689894e-03 3.025973e-01
99.9% 1.830769e-08 1.004481e+00 1.001123e+00 2.086381e+00 1.702812e+00
100%  3.419518e-07 2.939441e+00 2.019487e+01 2.578130e+01 2.050565e+01
           d Sig22
0%    0.000000e+00
5%    4.548288e-12
10%   1.525853e-11
15%   2.614724e-11
20%   3.792449e-11
25%   5.093322e-11
30%   6.421398e-11
35%   7.887044e-11
40%   9.421111e-11
45%   1.128333e-10
50%   1.326904e-10
55%   1.578749e-10
60%   1.881485e-10
65%   2.220852e-10
70%   2.698587e-10
75%   3.482424e-10
80%   4.746357e-10
85%   7.769432e-10
90%   2.075273e-09
95%   4.225295e-08
99%   6.303301e-03
99.9% 1.000044e+00
100%  3.153521e+01
> 
> # check the computation time
> bench::mark(
+   `method 0` = pbvn_grad(mu = mu, Sigma = Sigma, method = 0),
+   `method 1` = pbvn_grad(mu = mu, Sigma = Sigma, method = 1),
+   check = FALSE)
# A tibble: 2 × 13
  expression     min  median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time
  <bch:expr> <bch:t> <bch:t>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm>
1 method 0    5.75µs  5.85µs   165873.        0B     0    10000     0     60.3ms
2 method 1   10.09µs 10.47µs    89616.        0B     8.96  9999     1    111.6ms
# … with 4 more variables: result <list>, memory <list>, time <list>, gc <list>
> 
> # # plot the errors versus the integral value
> # vals <- errs["integral", "truth", ]
> #
> # par(mar = c(5, 5, 1, 1))
> # plot(vals, errs["d mu1", "relative", ], type = "h")
> # plot(vals, errs["d Sig12", "relative", ], type = "h")
> # plot(vals, errs["d mu1", "absolute", ], type = "h")
> # plot(vals, errs["d Sig12", "absolute", ], type = "h")
> #
> # rhos <- errs["integral", "rho", ]
> # plot(rhos, errs["d mu1", "relative", ], type = "h")
> # plot(rhos, errs["d Sig12", "relative", ], type = "h")
> #
> # # may fail with a large absolute correlation coefficient
> # plot(rhos, errs["integral", "absolute", ], type = "h")
> # plot(rhos, errs["d mu1", "absolute", ], type = "h")
> # plot(rhos, errs["d mu2", "absolute", ], type = "h")
> # plot(rhos, errs["d Sig11", "absolute", ], type = "h")
> # plot(rhos, errs["d Sig12", "absolute", ], type = "h")
> # plot(rhos, errs["d Sig22", "absolute", ], type = "h")
> #
> # vals <- errs["integral", "mu_std1", ]
> # plot(rhos, errs["d mu1", "relative", ], type = "h")
> # plot(rhos, errs["d mu2", "relative", ], type = "h")
> # vals <- errs["integral", "mu_std2", ]
> # plot(rhos, errs["d mu1", "relative", ], type = "h")
> # plot(rhos, errs["d mu2", "relative", ], type = "h")
> #
> # local({
> #   keep <- abs(rhos) < .99
> #   rhos <- rhos[keep]
> #   errs <- errs[, , keep]
> #
> #   plot(rhos, errs["integral", "absolute", ], type = "h")
> #   plot(rhos, errs["d mu1", "absolute", ], type = "h")
> #   plot(rhos, errs["d mu2", "absolute", ], type = "h")
> #   plot(rhos, errs["d Sig11", "absolute", ], type = "h")
> #   plot(rhos, errs["d Sig12", "absolute", ], type = "h")
> #   plot(rhos, errs["d Sig22", "absolute", ], type = "h")
> # })
> 
> proc.time()
   user  system elapsed 
311.162   0.107 311.327 
