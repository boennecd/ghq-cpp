
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(mvtnorm)
> library(ghqCpp)
> 
> # compute relative errors for different configurations with the two
> # implementations
> comp_errors <- \(method)
+ sapply(seq_len(1e4), \(i){
+   set.seed(i)
+   truth <- -Inf
+   while(!is.finite(truth) || truth < 1e-12){
+     Sigma <- rWishart(1, 2, diag(2)) |> drop()
+     mu <- rnorm(2)
+     truth <- pmvnorm(upper = numeric(2), mean = mu, sigma = Sigma)
+   }
+ 
+   # compute the error and return
+   est <- pbvn(mu, Sigma, method = method)
+   c(absolute = est - truth, relative = (est - truth) / truth, truth = truth)
+ }, simplify = "array")
> 
> errs_method0 <- comp_errors(0)
> errs_method1 <- comp_errors(1)
> 
> # look at stats for the absolute errors
> abs(errs_method0[c("absolute", "relative"), ]) |>
+   apply(1, quantile,
+         probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
          absolute     relative
0%    0.000000e+00 0.000000e+00
5%    2.077331e-17 2.823690e-16
10%   7.913783e-17 6.271763e-16
15%   1.387779e-16 7.067038e-16
20%   2.220446e-16 8.209196e-16
25%   2.775558e-16 1.006444e-15
30%   3.885781e-16 4.829078e-15
35%   5.551115e-16 1.312518e-13
40%   1.889322e-14 3.974367e-12
45%   1.259465e-12 7.187981e-11
50%   2.231795e-11 7.014727e-10
55%   1.806270e-10 4.592123e-09
60%   1.706358e-09 3.530954e-08
65%   1.000738e-08 1.659283e-07
70%   3.725718e-08 4.492362e-07
75%   9.075721e-08 9.453733e-07
80%   1.834370e-07 1.688521e-06
85%   3.278779e-07 2.768548e-06
90%   5.198873e-07 4.645308e-06
95%   8.714072e-07 7.595871e-06
99%   1.356756e-06 1.042974e-05
99.9% 1.655097e-06 3.348852e-05
100%  1.729089e-06 6.809305e-05
> abs(errs_method1[c("absolute", "relative"), ]) |>
+   apply(1, quantile,
+         probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
          absolute     relative
0%    0.000000e+00 0.000000e+00
5%    0.000000e+00 0.000000e+00
10%   0.000000e+00 0.000000e+00
15%   0.000000e+00 0.000000e+00
20%   0.000000e+00 0.000000e+00
25%   0.000000e+00 0.000000e+00
30%   0.000000e+00 0.000000e+00
35%   0.000000e+00 0.000000e+00
40%   5.963112e-19 1.219496e-16
45%   6.938894e-18 1.472902e-16
50%   1.387779e-17 1.748142e-16
55%   2.775558e-17 2.053557e-16
60%   2.775558e-17 2.548168e-16
65%   5.551115e-17 3.418622e-16
70%   5.551115e-17 4.250891e-16
75%   5.551115e-17 5.755743e-16
80%   8.326673e-17 7.793083e-16
85%   1.110223e-16 1.246320e-15
90%   1.110223e-16 3.088349e-15
95%   1.665335e-16 2.651456e-14
99%   2.220446e-16 2.875940e-10
99.9% 8.881784e-16 1.255796e-06
100%  1.793353e-15 2.189607e-05
> 
> # compare the computation time
> set.seed(1)
> Sigma <- rWishart(1, 2, diag(2)) |> drop()
> mu <- rnorm(2)
> 
> bench::mark(
+   `pbvn method 0` = pbvn(mu, Sigma, method = 0),
+   `pbvn method 1` = pbvn(mu, Sigma, method = 1),
+   check = FALSE)
# A tibble: 2 × 13
  expression         min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc
  <bch:expr>    <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>
1 pbvn method 0   6.61µs   6.75µs   142473.        0B     14.2  9999     1
2 pbvn method 1   1.25µs   1.39µs   613003.        0B      0   10000     0
# … with 5 more variables: total_time <bch:tm>, result <list>, memory <list>,
#   time <list>, gc <list>
> 
> # check the gradient
> library(numDeriv)
> errs <- sapply(seq_len(1e4), \(i){
+   set.seed(i)
+   truth <- -Inf
+   while(!is.finite(truth) || truth < 1e-12){
+     Sigma <- rWishart(1, 2, diag(2)) |> drop()
+     mu <- rnorm(2)
+     truth <- pmvnorm(upper = numeric(2), mean = mu, sigma = Sigma)
+   }
+ 
+   # compute the gradient numerically of the log of the interval
+   fn <- pmvnorm(upper = numeric(2), mean = mu, sigma = Sigma)
+   num_grad <- grad(
+     \(par) {
+       mu <- head(par, 2)
+       S <- matrix(nrow = 2, ncol = 2)
+       S[upper.tri(S, TRUE)] <- tail(par, 3)
+       S[lower.tri(S)] <- t(S)[lower.tri(S)]
+ 
+       pmvnorm(upper = numeric(2), mean = mu, sigma = S)
+     }, c(mu, Sigma[upper.tri(Sigma, TRUE)]), method.args = list(r = 6))
+ 
+   # compute the gradient, compute the error and return
+   est <- pbvn_grad(mu = mu, Sigma = Sigma)
+ 
+   # only keep the upper triangle
+   d_Sig <- tail(est, 4) |> matrix(nrow = 2)
+   d_Sig[upper.tri(d_Sig)] <- 2 * d_Sig[upper.tri(d_Sig)]
+   val <- attr(est, "prob")
+   est <- c(val, c(head(est, 2), d_Sig[upper.tri(d_Sig, TRUE)]) / val)
+ 
+   truth <- c(fn, num_grad / fn) |>
+     setNames(c("integral", "d mu1", "d mu2", "d Sig11", "d Sig12",
+                "d Sig22"))
+   err <- est - truth
+   relative = ifelse(abs(truth) < 1e-12, err, err / abs(truth))
+ 
+   cbind(absolute = err, relative = relative, truth = truth, est,
+         rho = cov2cor(Sigma)[1, 2], mu_std1 = mu[1] / sqrt(Sigma[1, 1]),
+         mu_std2 = mu[2] / sqrt(Sigma[2, 2]))
+ }, simplify = "array")
> 
> # quantiles of the absolute error
> apply(abs(errs[, "absolute", ]),
+       1, quantile, probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
          integral        d mu1        d mu2      d Sig11      d Sig12
0%    0.000000e+00 0.000000e+00 0.000000e+00 7.042189e-16 9.983656e-19
5%    0.000000e+00 4.652314e-12 6.083862e-12 3.734148e-12 7.765815e-14
10%   0.000000e+00 3.029277e-11 3.326514e-11 2.324387e-11 1.999468e-12
15%   0.000000e+00 1.437440e-10 1.665410e-10 1.452553e-10 7.052801e-12
20%   0.000000e+00 9.914817e-10 1.070699e-09 1.389385e-09 1.541274e-11
25%   0.000000e+00 7.911551e-09 9.183463e-09 1.236994e-08 3.149298e-11
30%   0.000000e+00 7.557336e-08 7.721893e-08 9.992634e-08 8.106762e-11
35%   0.000000e+00 4.831347e-07 4.665770e-07 4.659431e-07 4.007047e-10
40%   2.253446e-18 1.469144e-06 1.394617e-06 1.354457e-06 2.364012e-09
45%   9.852211e-18 3.218253e-06 2.985442e-06 3.368986e-06 1.638941e-08
50%   1.725521e-17 6.198451e-06 5.988043e-06 8.993324e-06 9.480844e-08
55%   2.775558e-17 1.105654e-05 1.084327e-05 2.311396e-05 4.763596e-07
60%   3.469447e-17 1.870330e-05 1.794337e-05 4.216198e-05 1.354511e-06
65%   5.551115e-17 2.647039e-05 2.593558e-05 6.326057e-05 2.852950e-06
70%   5.551115e-17 3.351566e-05 3.271096e-05 9.165073e-05 5.080753e-06
75%   6.245005e-17 4.091283e-05 3.981769e-05 1.238393e-04 8.720101e-06
80%   1.110223e-16 4.907988e-05 4.866795e-05 1.690583e-04 1.370031e-05
85%   1.110223e-16 6.042161e-05 6.051069e-05 2.476848e-04 2.109466e-05
90%   1.110223e-16 7.762072e-05 7.864444e-05 3.962716e-04 3.436583e-05
95%   1.665335e-16 1.144606e-04 1.163755e-04 8.425932e-04 7.421638e-05
99%   2.220446e-16 2.796045e-04 2.881819e-04 5.694890e-03 1.207537e-03
99.9% 8.881784e-16 2.044632e-01 2.494259e-01 6.264144e+02 2.793756e+04
100%  1.793353e-15 5.466099e+00 1.514324e+01 3.775189e+05 1.153060e+06
           d Sig22
0%    1.489803e-16
5%    3.803780e-12
10%   2.506277e-11
15%   1.481813e-10
20%   1.444055e-09
25%   1.438102e-08
30%   9.339866e-08
35%   4.224810e-07
40%   1.199012e-06
45%   3.015237e-06
50%   8.316486e-06
55%   2.185476e-05
60%   4.160476e-05
65%   6.188199e-05
70%   8.719169e-05
75%   1.202039e-04
80%   1.681513e-04
85%   2.492110e-04
90%   4.060758e-04
95%   9.148211e-04
99%   5.277276e-03
99.9% 4.006217e+02
100%  7.263380e+06
> 
> # quantiles of the relative error
> apply(abs(errs[, "relative", ]),
+       1, quantile, probs = seq(0, 1, length.out = 21) |> c(.99, .999) |> sort())
          integral        d mu1        d mu2      d Sig11      d Sig12
0%    0.000000e+00 0.000000e+00 0.000000e+00 7.042189e-16 9.983656e-19
5%    0.000000e+00 2.433466e-11 2.529383e-11 2.245977e-11 8.146600e-14
10%   0.000000e+00 1.603700e-10 1.678077e-10 9.414095e-11 1.062631e-11
15%   0.000000e+00 8.283596e-10 8.986355e-10 4.867149e-10 3.875977e-11
20%   0.000000e+00 4.931528e-09 5.414184e-09 7.314686e-09 8.641183e-11
25%   0.000000e+00 4.748835e-08 5.325240e-08 8.862622e-08 3.354576e-10
30%   0.000000e+00 4.804861e-07 4.326530e-07 9.856582e-07 1.893014e-09
35%   0.000000e+00 1.864078e-06 1.744235e-06 3.928510e-06 8.362219e-09
40%   1.335971e-16 4.348624e-06 4.098404e-06 9.579224e-06 4.020793e-08
45%   1.572131e-16 7.287946e-06 6.987306e-06 1.753713e-05 2.666388e-07
50%   1.833205e-16 9.863520e-06 9.634107e-06 3.346130e-05 1.270204e-06
55%   2.134210e-16 1.426886e-05 1.372978e-05 6.952553e-05 3.390079e-06
60%   2.689086e-16 2.326414e-05 2.245587e-05 1.423297e-04 6.897416e-06
65%   3.522361e-16 3.434999e-05 3.401712e-05 2.788235e-04 1.048483e-05
70%   4.319584e-16 4.428709e-05 4.374170e-05 4.845131e-04 1.466588e-05
75%   5.868145e-16 5.411434e-05 5.337578e-05 8.201916e-04 1.932552e-05
80%   7.932379e-16 6.420058e-05 6.316718e-05 1.327269e-03 2.574240e-05
85%   1.256386e-15 7.706613e-05 7.600901e-05 1.936097e-03 3.456690e-05
90%   3.093214e-15 9.848020e-05 9.656036e-05 3.230405e-03 5.379870e-05
95%   2.651456e-14 1.406136e-04 1.354891e-04 7.807948e-03 3.081018e-04
99%   2.875940e-10 1.003888e-02 9.926030e-03 1.310886e-01 1.000000e+00
99.9% 1.255796e-06 1.000000e+00 1.000005e+00 3.663448e+01 2.013237e+03
100%  2.189607e-05 2.938602e+00 2.020181e+01 1.074913e+03 1.127653e+08
           d Sig22
0%    1.489803e-16
5%    2.256289e-11
10%   9.667123e-11
15%   4.776410e-10
20%   6.789673e-09
25%   9.621265e-08
30%   9.274062e-07
35%   3.846217e-06
40%   9.394678e-06
45%   1.707656e-05
50%   3.168835e-05
55%   6.633312e-05
60%   1.446715e-04
65%   2.754710e-04
70%   4.724265e-04
75%   8.105494e-04
80%   1.307708e-03
85%   1.904768e-03
90%   3.045559e-03
95%   7.530431e-03
99%   2.592348e-01
99.9% 1.761120e+01
100%  5.265625e+02
> 
> # check the computation time
> bench::mark(pbvn_grad(mu = mu, Sigma = Sigma))
# A tibble: 1 × 13
  expression                             min median `itr/sec` mem_alloc `gc/sec`
  <bch:expr>                        <bch:tm> <bch:>     <dbl> <bch:byt>    <dbl>
1 pbvn_grad(mu = mu, Sigma = Sigma)   6.25µs 6.37µs   152194.        0B        0
# … with 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>,
#   result <list>, memory <list>, time <list>, gc <list>
> 
> # # plot the errors versus the integral value
> # vals <- errs["integral", "truth", ]
> #
> # par(mar = c(5, 5, 1, 1))
> # plot(vals, errs["d mu1", "relative", ], type = "h")
> # plot(vals, errs["d Sig12", "relative", ], type = "h")
> # plot(vals, errs["d mu1", "absolute", ], type = "h")
> # plot(vals, errs["d Sig12", "absolute", ], type = "h")
> #
> # rhos <- errs["integral", "rho", ]
> # plot(rhos, errs["d mu1", "relative", ], type = "h")
> # plot(rhos, errs["d Sig12", "relative", ], type = "h")
> #
> # # may fail with a large absolute correlation coefficient
> # plot(rhos, errs["integral", "absolute", ], type = "h")
> # plot(rhos, errs["d mu1", "absolute", ], type = "h")
> # plot(rhos, errs["d mu2", "absolute", ], type = "h")
> # plot(rhos, errs["d Sig11", "absolute", ], type = "h")
> # plot(rhos, errs["d Sig12", "absolute", ], type = "h")
> # plot(rhos, errs["d Sig22", "absolute", ], type = "h")
> #
> # vals <- errs["integral", "mu_std1", ]
> # plot(rhos, errs["d mu1", "relative", ], type = "h")
> # plot(rhos, errs["d mu2", "relative", ], type = "h")
> # vals <- errs["integral", "mu_std2", ]
> # plot(rhos, errs["d mu1", "relative", ], type = "h")
> # plot(rhos, errs["d mu2", "relative", ], type = "h")
> #
> # local({
> #   keep <- abs(rhos) < .99
> #   rhos <- rhos[keep]
> #   errs <- errs[, , keep]
> #
> #   plot(rhos, errs["integral", "absolute", ], type = "h")
> #   plot(rhos, errs["d mu1", "absolute", ], type = "h")
> #   plot(rhos, errs["d mu2", "absolute", ], type = "h")
> #   plot(rhos, errs["d Sig11", "absolute", ], type = "h")
> #   plot(rhos, errs["d Sig12", "absolute", ], type = "h")
> #   plot(rhos, errs["d Sig22", "absolute", ], type = "h")
> # })
> 
> proc.time()
   user  system elapsed 
156.601   0.080 156.650 
